#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <unistd.h>


#include <system.h>
#include <sys/alt_alarm.h>
#include <io.h>

#include "fatfs.h"
#include "diskio.h"

#include "ff.h"
#include "monitor.h"
#include "uart.h"

#include "alt_types.h"
#include "altera_avalon_pio_regs.h"
#include "sys/alt_irq.h"
#include <altera_up_avalon_audio.h>
#include <altera_up_avalon_audio_and_video_config.h>


#include "sys/alt_stdio.h"

// GLOBAL VARIABLES THAT WE CREATED

	const int MAX_TRACKS = 14;
	char trackList[14][64] = {0};
	uint32_t trackSize[14] = {0};
	int totalTracks = 0;
	volatile int trackPtr = 0;
	volatile int is_playing = 0;
	volatile int is_prev = 0;
	volatile int is_next = 0;
	//int stop = 0;
	volatile int state = 0; // 0 - stop, 1 -play, 2 - pause
	static alt_u32 lastPb1 = 0;
	static alt_u32 lastPb2 = 0;
	static alt_u32 lastPb3 = 0;
	static alt_u32 lastPb4 = 0;

	FATFS Fatfs[1];
	// needed for timer function but not sure what that needed for...
	static alt_alarm alarm1;
	static unsigned long Systick = 0;
	static volatile unsigned short Timer;   /* 1000Hz increment timer */

	static alt_u32 last_button_press = 0; // track time from last button press
	static int last_displayed_state = -1;  // Initialize to a value that won't match any state


	// Button Interrupt Handler
	static void buttonHandler(void * context, alt_u32 id){

		alt_u32 now = Systick;
		if((now - last_button_press) < 200) {
		    IOWR(BUTTON_PIO_BASE, 3, 0x0);
		    return;
		}

		alt_u32 button_edge = IORD(BUTTON_PIO_BASE, 3);
		IOWR(BUTTON_PIO_BASE, 3, 0x0);

		//skip button pb0
		if ((button_edge & 0x01) && ((now - lastPb1) > 50)) {
			is_next = 1;
			if(state==1){
				state = 1;
			}else{
				state = 0;
			}

		    //lastPb1 = now;
			last_button_press = now;
		    printf("made state %d and isPlaying %d! Skipping\n", state, is_playing);
		}
		//pause/play pb 1
		if ((button_edge & 0x02) && ((now - lastPb2) > 50)) {
			if(state==1){
				state = 2;

			}else{
				state = 1;
			}

			//lastPb2 = now;
			last_button_press = now;
			printf("made state %d and isPlaying %d! Pausing/Playing\n", state, is_playing);
		}
		//stop pb 2
		if ((button_edge & 0x04) && ((now - lastPb3) > 50)) {
			state = 0;
			//lastPb3 = now;
			last_button_press = now;
			printf("made state %d and isPlaying %d! Stopping\n", state, is_playing);
		}
		//prev track pb 3
		if ((button_edge & 0x08) && ((now - lastPb4) > 50)) {
			if(state==1){
				state = 1;
			}else{
				state = 0;
			}
			is_prev = 1;
			//lastPb4 = now;
			last_button_press = now;
			printf("made state %d and isPlaying %d! Previous\n", state, is_playing);
		}
		IOWR(BUTTON_PIO_BASE, 3, 0x0); //clear edge capture register
	}



static alt_u32 TimerFunction (void *context)
	{
	   static unsigned short wTimer10ms = 0;

	   (void)context;

	   Systick++;
	   wTimer10ms++;
	   Timer++; /* Performance counter for this module */

	   if (wTimer10ms == 10)
	   {
	      wTimer10ms = 0;
	      ffs_DiskIOTimerproc();  /* Drive timer procedure of low level disk I/O module */
	   }

	  return(1);
	}

// function to initialize disk
static void IoInit(void)
	{
	   uart0_init(115200);

	   /* Init diskio interface */
	   ffs_DiskIOInit();

	   //SetHighSpeed();

	   /* Init timer system */
	   alt_alarm_start(&alarm1, 1, &TimerFunction, NULL);

	}

void initialize_and_read_files() {
    uint8_t drv = 0;
    uint32_t p1, p2;
    FRESULT res;

    // Initialize Disk (di 0)
    printf("Initializing disk...\n");
    res = disk_initialize(drv);

    if (res != RES_OK) {
        printf("Disk initialization failed with error code: %d\n", res);
        return;
    }

    printf("Disk initialized successfully\n");

    // Force Mount Logical Drive (fi 0)

    res = f_mount(drv, &Fatfs[drv]);

    if (res != FR_OK) {
        printf("Failed to mount the file system with error code: %d\n", res);
        return;
    }

    printf("File system mounted successfully\n");

    // list and store files from SD ( fl )
    DIR Dir;
    FILINFO Finfo;
    res = f_opendir(&Dir, "/");  // Open root directory

    if (res != FR_OK) {
        printf("Failed to open directory with error code: %d\n", res);
        return;
    }

    totalTracks = 0;

    while (1) {
        res = f_readdir(&Dir, &Finfo);  // Read directory entry

        if (res != FR_OK || Finfo.fname[0] == '\0')  // No more files
            break;

        // Only add .WAV files to trackList
        if (strstr(Finfo.fname, ".WAV")) {
            if (totalTracks < MAX_TRACKS) {
                strcpy(trackList[totalTracks], Finfo.fname);  // Store filename
                trackSize[totalTracks] = Finfo.fsize;  // Store file size
                totalTracks++;
            }
        }
    }
    printf("Found %d tracks:\n", totalTracks);

    for (int i = 0; i < totalTracks; i++) {
        printf("%d: %s, Size: %s bytes\n", i + 1, trackList[i], trackSize[i]);
    }
}



void pause_track() {
	printf("Track Paused\n");
}

void writeToLCD(int trackPtr, int state){
    // Only update if the state has changed
    if (state != last_displayed_state) {
        FILE *lcd = fopen("/dev/lcd_display", "w");
        if (lcd != NULL) {
            fprintf(lcd, "\x1b[2J");  // Clear LCD
            fprintf(lcd, "%s - Track %d\n", trackList[trackPtr], trackPtr);  // Display current track
            switch(state) {
                case 0:  // Stop mode
                    fprintf(lcd, "Stop Mode");
                    break;
                case 1:  // Play mode
                    fprintf(lcd, "Play Mode");
                    break;
                case 2:  // Pause mode
                    fprintf(lcd, "Pause Mode");
                    break;
            }
            fclose(lcd);
        }
        last_displayed_state = state;  // Update the last displayed state
    }
}


//maybe do interrupt based approach for the push buttons

int main()
{
// Needed Variables for set up
alt_up_audio_dev * audio_dev;
/* used for audio record/playback */
uint8_t Buff[8192] __attribute__ ((aligned(4)));  /* Working buffer */ // working buffer for set up with no user command
IOWR(BUTTON_PIO_BASE, 2, 0x0F);
alt_irq_register( BUTTON_PIO_IRQ, NULL, buttonHandler);
// Set up
IoInit(); // initialize board
initialize_and_read_files(); // initialize and read/store

    audio_dev = alt_up_audio_open_dev("/dev/Audio");
    printf("1\n");

    FIL File1;
    FRESULT result;

    unsigned int bytesRead;
    unsigned char buffer[1024];     // temporary buffer
    unsigned int l_buf;
    unsigned int r_buf;

    // Use the correct string for opening the file
    char *current_file = trackList[trackPtr];  // Correcting this line
    result = f_open(&File1, current_file, FA_READ); // file opened => add error check if needed => I THINK FA_READ IS WRONG IDK HOW TO FIX...
    unsigned int bytes_remaining = trackSize[trackPtr];

    if (result != FR_OK) {
        printf("Error opening file %s\n", current_file);
         // Stop execution if file cannot be opened
    }else{
    	printf("File opened!\n");
    }

    // 0 0 - normal speed, 0 1 - half speed, 1 0 - double speed, 1 1 - normal speed mono
    printf("Playing Track: %s\n", trackList[trackPtr]);

    // open the Audio port and only open the audio device once, no need to open it again
    // audio_dev = alt_up_audio_open_dev("/dev/Audio");
    if (audio_dev == NULL){
        alt_printf("Error: could not open audio device \n");
    }

    /* read and echo audio data */

    int i = 0;
    while (1) {
    	//printf("state %d\n", state);
    	int switch_state = (IORD(SWITCH_PIO_BASE, 0)) & 0x01; //SW0
    	    int switch_state2 = (IORD(SWITCH_PIO_BASE, 0) >> 1) & 0x01; //SW1

    	    int isMono = 0;
    	    int speedSetting = 0;

    	    if (switch_state2 == 1) {
    	        if (switch_state == 1) {
    	            // MONO
    	            speedSetting = 4;
    	            isMono = 1;
    	        } else {
    	            // DOUBLE SPEED
    	            speedSetting = 8;
    	        }
    	    } else {
    	        if (switch_state == 1) {
    	            // HALF SPEED
    	            speedSetting = 2;
    	            //printf("double state\n");
    	        } else {
    	            // NORMAL
    	            speedSetting = 4;
    	        }
    	    }

    	if(is_prev){
    		is_prev = 0;
    		trackPtr = (trackPtr -1 + MAX_TRACKS) % MAX_TRACKS;
    		current_file = trackList[trackPtr];
    		bytes_remaining = trackSize[trackPtr];
    		f_close(&File1);
    		result = f_open(&File1, current_file, 1);
    	}

    	if(is_next){
    		trackPtr = (trackPtr +1 ) % MAX_TRACKS;
    		current_file = trackList[trackPtr];
    		bytes_remaining = trackSize[trackPtr];
    		is_next = 0;
    		f_close(&File1);
    		result = f_open(&File1, current_file, 1);
    	}
    	switch(state){

    	case 0: //stop
    		//stop the track and reset the pointer to the beginning

    		   // Code to stop the track
    		   if(!is_playing){
    			   writeToLCD(trackPtr, state);
    			   is_playing = 0;
    		   }
    		   i = 0;
    		   f_lseek(&File1, 0);
    		   is_playing = 0;

    		   break;

    	case 1: //play

    		result = f_read(&File1, buffer, sizeof(buffer), &bytesRead);

    		if(bytesRead > 0){
    			 FILE *lcd = fopen("/dev/lcd_display", "w");
    			 fclose(lcd);
    		}
    		bytes_remaining -= bytesRead;

    		if (bytes_remaining == 0) {
    		    		state = 0;  // Stop state when end of track is reached
    		    		is_playing = 0;
    		    		writeToLCD(trackPtr, state);
    		    		f_lseek(&File1, 0);
    		    		//break; => not sure if this is needed, sometimes it gets stuck on play mode and does not go to stop mode
    		    	}
    		for ( i = 0; i < bytesRead; i += speedSetting) {
    		    // little endian

    			if(!is_playing){
    				writeToLCD(trackPtr, state);
    				is_playing = 1;
    			}
    		    unsigned int left = (buffer[i + 1] << 8) | buffer[i];
    		    unsigned int right = (buffer[i + 3] << 8) | buffer[i + 2];

    		    if (isMono == 0) {
    		    	//printf("not mono\n");
    		    	// alt_up_audio_write_fifo_space returns num of free slots in the left channel
    		    	while (alt_up_audio_write_fifo_space(audio_dev, ALT_UP_AUDIO_LEFT) == 0) {} // while fifo is full, do nothing
    		    	alt_up_audio_write_fifo(audio_dev, &left, 1, ALT_UP_AUDIO_LEFT); // writes one sample to the left fifo
    		    	// returns num of free slots in the right channel
    		    	while (alt_up_audio_write_fifo_space(audio_dev, ALT_UP_AUDIO_RIGHT) == 0) {} // while fifo is full, do nothing
    		    	alt_up_audio_write_fifo(audio_dev, &right, 1, ALT_UP_AUDIO_RIGHT); // writes one sample to right fifo
    		    } else if (isMono == 1) {
    		    	//printf("mono\n");
    		    	// for mono, only play on the left channel
    		    	while (alt_up_audio_write_fifo_space(audio_dev, ALT_UP_AUDIO_LEFT) == 0) {} // while fifo is full, do nothing
    		    	alt_up_audio_write_fifo(audio_dev, &left, 1, ALT_UP_AUDIO_LEFT); // writes one sample to the left fifo
    		    	// unsigned int silence = 0;
    		    	while (alt_up_audio_write_fifo_space(audio_dev, ALT_UP_AUDIO_RIGHT) == 0) {} // while fifo is full, do nothing
    		    	alt_up_audio_write_fifo(audio_dev, &left, 1, ALT_UP_AUDIO_RIGHT); // writes one sample to right fifo
    		    }
    		 }
    		break;

    	case 2: //pause
    		if(is_playing){ //allows us to update the lcd only once
    			is_playing = 0;
    			writeToLCD(trackPtr, state);
    		}
    		break;



    }
    //f_close(&File1);
    }
  return 0;
}
